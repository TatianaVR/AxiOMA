#include "project.h"
#include "ui_project.h"

#include "widget.h"

using namespace std;

#define DELTA 5.0
Project::Project(QWidget *parent) :
    QWidget(parent),
    ui(new Ui::Project)
{
    ui->setupUi(this);

    //Задание вектора, хранящего минимум и максимум осей коориднат
    extremumValues.fill(0.0, 2); // extremumValuesх[0] <- min,  extremumValues[1] <- max

    //Подписываем оси Ox и Oz
    ui->widget->xAxis->setLabel("Z");
    ui->widget->yAxis->setLabel("X");

    setSelectCenterEnable(false);
    setTransitionEnable(false);

    //при выборе в соответствующем окне элемента вызывается функция выделения его на графике
    connect(ui->EventList, SIGNAL(currentItemChanged(QListWidgetItem*, QListWidgetItem*)), this, SLOT(repaintSelectedElement(QListWidgetItem*, QListWidgetItem*)));
    connect(ui->widget, SIGNAL(mousePress(QMouseEvent*)), this, SLOT(definitionItemIndex(QMouseEvent*)));
    connect(ui->widget, SIGNAL(mouseMove(QMouseEvent*)), this, SLOT(showToolTip(QMouseEvent*)));

    //очистка полей ввода при наведении курсора
    foreach (QDoubleSpinBox * spinBox, this->findChildren<QDoubleSpinBox *>()) //поиск всех элементов, предназначенных для ввода данных
    {
        foreach (QObject *editLine, spinBox->children()) //вычленяем из элементов поле ввода
        {
            editLine->installEventFilter(this); //переопределяем событие нажатия мышки по полю ввода (см. bool Project::eventFilter(QObject *obj, QEvent *event))
        }
    }
}

//Удаление формы
Project::~Project()
{
    delete ui;
}

//обработчик событий для очистки полей ввода при наведении курсора
bool Project::eventFilter(QObject *obj, QEvent *event)
{
    if(event->type() == QEvent::MouseButtonPress) //проверка события нажатия кнопки мыши
    {
        qobject_cast<QLineEdit*>(obj)->clear(); //если объект - поле ввода, то очищаем его
    }
    return false;
}

//Снятие выделения с выбранного элемента
void Project::mousePressEvent(QMouseEvent *event)
{
    Q_UNUSED(event)
    if (!ui->EventList->selectedItems().isEmpty())
    {
        cleanSpinBox();
        ui->EventList->clearSelection();
        blank[ui->EventList->currentRow()]->getGraph()->setSelected(false);
        ui->widget->replot();
    }
}

//Hot Keys
void Project::keyPressEvent(QKeyEvent *event)
{
    switch (event->key())
    {
    case Qt::Key_Z:
        on_HorizontalLineButton_clicked();
        break;
    case Qt::Key_X:
        on_VerticalLineButton_clicked();
        break;
    case Qt::Key_C:
        on_CurveButton_clicked();
        break;
    case Qt::Key_V:
        on_LineButton_clicked();
        break;
    default:
        break;
    }
}

//Функция, обрабатывающая входящие параметры при открытии текущего окна
//project_name - имя проекта / isExist - триггер, определяющий открываем новый файл или уже существующий
void Project::recieveOptions(QString project_name, bool isExist)
{
    ui->string_name->setText(project_name); //вывод имени заготовки
    ui->ElementParametrs->setCurrentIndex(0);
    if (isExist) //если открываем существующий файл
    {
        ui->CreateButton->setEnabled(false);
        parseFile(project_name); //производим парсинг этого файла
    }
     //даем пользователю возможность производить с заготовкой дальнейшие манипуляции : добавление подсказки в Лог
    blank.size() != 0 ? setAddEnable(true) : logAction(messageType::INITIALIZATION_BLANK);
}

//Функция очистки старых значений в полях (значение по умолчанию в 0)
void Project::cleanSpinBox()
{
    QList<QDoubleSpinBox *> elements = this->findChildren<QDoubleSpinBox *>();
    for(int i = 0; i < elements.size(); i++)
    {
        elements[i]->setValue(0.0);
    }

    ui->argAlpha_value->setCurrentIndex(0);

    ui->CreateButton->setEnabled(true);
    ui->RemoveButton->setEnabled(false);
    ui->ChangeButton->setEnabled(false);

}

//Скрыть / раскрыть окно параметров для ввода параметров фасок и скруглений (при вводе начальной точки и дуги данный функционал не доступен)
void Project::setTransitionEnable(bool isEnable)
{
    for(int i = 0; i < ui->TransitionItem->count(); i++)
    {
        ui->TransitionItem->itemAt(i)->widget()->setVisible(isEnable);
    }
}

//Скрыть / раскрыть окно параметров для выбора центра окружности
void Project::setSelectCenterEnable(bool isEnable)
{
    for(int i = 0; i < ui->SelectCenter->count(); i++)
    {
        ui->SelectCenter->itemAt(i)->widget()->setVisible(isEnable);
    }
}

void Project::setAddEnable(bool isEnabled)
{
    ui->VerticalLineButton->setEnabled(isEnabled);
    ui->HorizontalLineButton->setEnabled(isEnabled);
    ui->LineButton->setEnabled(isEnabled);
    ui->CurveButton->setEnabled(isEnabled);
}

//======================================
//==== структура = тела = функции ======
// очистка всех полей ввода параметров
// задание ID добавляемого элемента
// вывод соответствующего окна параметров
//======================================
//Нажатие кнопки для добавления прямой Z
void Project::on_HorizontalLineButton_clicked()
{
    cleanSpinBox();
    ui->ElementParametrs->setCurrentIndex(1);
    setTransitionEnable(true);
}

//Нажатие кнопки для добавления прямой X
void Project::on_VerticalLineButton_clicked()
{
    cleanSpinBox();
    ui->ElementParametrs->setCurrentIndex(2);
    setTransitionEnable(true);
}

//Нажатие кнопки для добавления прямой
void Project::on_LineButton_clicked()
{
    cleanSpinBox();
    ui->ElementParametrs->setCurrentIndex(3);
    setTransitionEnable(true);
}

//Нажатие кнопки для добавления дуги
void Project::on_CurveButton_clicked()
{
    cleanSpinBox();
    ui->DirectionButton->setStyleSheet("background: url(:/data/direction/left.png)");
    ui->ElementParametrs->setCurrentIndex(4);
    setTransitionEnable(false);
}
//======================================

//Функция изменения направления по или против часовой стрелки (смена иконки для соответствующей кнопки)
void Project::on_DirectionButton_clicked()
{
    if(ui->DirectionButton->styleSheet().contains("left"))
    {
        ui->DirectionButton->setStyleSheet("background: url(:/data/direction/right.png)");
    }
    else
    {
        ui->DirectionButton->setStyleSheet("background: url(:/data/direction/left.png)");
    }
    if(ui->label_3->isVisible())
    {
        blank.last()->getCodeElement() == "G02" ?  blank.last()->setCodeElement("G03") : blank.last()->setCodeElement("G02");
        redraw(blank.size() - 1);
    }
}

//Автоматическое вычисление масштаба осей
//xValues - все значения X добавляемого элемента / zValues - все значения Z
void Project::setAxesRange(QList<QCPCurveData> data)
{
    QVector <double> xValues, zValues;
    foreach (QCPCurveData item, data)
    {
        xValues.append(item.key);
        zValues.append(item.value);
    }
    //Вычисляем минимальные и максимальные значения для каждой из векторов xValues, zValues
    double minX, maxX, minZ, maxZ;
    minX = *min_element(xValues.constBegin(), xValues.constEnd());
    maxX = *max_element(xValues.constBegin(), xValues.constEnd());
    minZ = *min_element(zValues.constBegin(), zValues.constEnd());
    maxZ = *max_element(zValues.constBegin(), zValues.constEnd());
    //Выбор минимума из минимумов и максимума из максимумов каждого из векторов
    double max, min;
    minX < minZ ? min = minX : min = minZ;
    maxX < maxZ ? max = maxZ : max = maxX;
    //Находим минимум и максимум среди текущих и вычисленных для векторов xValues, zValues значений
    if(min < extremumValues[0])
    {
        extremumValues[0] = min;
    }
    if(max > extremumValues[1])
    {
        extremumValues[1] = max;
    }
    //Задаем найденные максимум и минимум в качестве диапазона каждой из осей с отступом DELTA по всем направлениям
    ui->widget->xAxis->setRange(extremumValues[0] - DELTA, extremumValues[1] + DELTA);
    ui->widget->yAxis->setRange(extremumValues[0] - DELTA, extremumValues[1] + DELTA);
    ui->widget->replot();
}

void Project::redraw(int index)
{
    blank[index]->draw(ui);
    setAxesRange(blank[index]->getGraph()->data()->values());
    ui->widget->replot();
}

//Функция, реализующая смену центра окружности при её добавлении
void Project::on_CircleCenter_sliderMoved(int position)
{
    Q_UNUSED(position);
    redraw(blank.size() - 1);
}

//Подтверждение выбранной окружности, её дальнейшее добавление в список всех элементов
void Project::on_AddCircleCenter_clicked()
{
    //Скрываем окно параметров для выбора центра окружности
    ui->CircleCenter->setValue(0);
    setSelectCenterEnable(false);

    //разблокируем кнопки для добавления других элементов
    setAddEnable(true);

    centers.clear();

    addToEventList(blank.size() - 1);
}

//Функция отрисовки фасок с пересчетом элементов
//index - индекс заданного элемента
void Project::drawChamfer(int index)
{
    if(transitions[index].FSX != 0.0)
    {
        transitions[index].FSZ = transitions[index].FSX / qTan(transitions[index].alpha);
    }
    else
    {
        transitions[index].FSX = transitions[index].FSZ / qTan(transitions[index].alpha);
    }

    if((isOrthogonal(blank[blank.size() - 2]->getStartPoint(), blank[blank.size() - 2]->getEndPoint(), blank[blank.size() - 1]->getStartPoint(), blank[blank.size() - 1]->getEndPoint())))
    {
        int id = -1;
        double val_y = 0.0;
        double angel = 0.0;
        if(dynamic_cast<HorizontalLine*>(blank[blank.size() - 2]))
        {
            id = blank.size() - 2;
            val_y = blank[id]->getEndPoint().y();
        }
        else
        {
            id = blank.size() - 1;
            val_y = blank[id]->getStartPoint().y();
        }
         transitions[index].alpha * (blank[id]->getStartPoint().y() > blank[id]->getEndPoint().y() ? -1.0 : 1.0);
        QVector <double> b(2);
        b[0] = blank[blank.size() - 2]->b1();
        b[1] = blank[id]->getStartPoint().x() - qTan(angel) * (val_y - transitions[index].FSX);
        qDebug() << blank[id]->getStartPoint().x();
        qDebug() << qTan(angel);
        qDebug() << val_y;
        qDebug() << val_y - transitions[index].FSX;
        qDebug() << b;
        QPointF point1, point2;
        point1 = SLAE(blank[blank.size() - 2]->matA(angel), b);

        b[0] = blank[blank.size() - 1]->b1();
        point2 = SLAE(blank[blank.size() - 1]->matA(angel), b);


        blank[blank.size() - 2]->setEndPoint(QPointF(point1.y(),point1.x()));
        redraw(blank.size() - 2);

        blank.append(new Line(QPointF(point1.y(),point1.x()), QPointF(point2.y(),point2.x())));
        redraw(blank.size() - 1);
        addToEventList(blank.size() - 1);

        BlankElement *swapItem = blank[blank.size() - 2];
        blank[blank.size() - 2] = blank[blank.size() - 1];
        blank[blank.size() - 1] = swapItem;

        blank[blank.size() - 1]->setStartPoint(QPointF(point2.y(),point2.x()));
        redraw(blank.size() - 1);
    }
    /*else if(blank[blank.size() - 2].id == blank[blank.size() - 1].id)
    {
        modifyPreviousElement(index);
        elem->setStartPoint(blank[blank.size() - 2]->getEndPoint());
        switch (blank[blank.size() - 1].id)
        {
            case 1:
                blank[blank.size() - 1].getEndPoint().rx() += transitions[index].FSX;
                blank[blank.size() - 1].getStartPoint().setX(blank[blank.size() - 1].getEndPoint().x());
                break;
            case 2:
                blank[blank.size() - 1].getEndPoint().ry() += transitions[index].FSZ;
                blank[blank.size() - 1].getStartPoint().setY(blank[blank.size() - 1].getEndPoint().y());
                break;
            default:
                break;
        }
    }*/
    else
    {
        logAction(messageType::JUNCTION_ERROR);
        return;
    }
}

//Функция отрисовки скруглений с пересчетом элементов
//index - индекс заданного элемента
void Project::drawRounding(int index)
{
    /*BlankElement elem, clone;
    elem.arcR = transitions[index].R;
    if(isOrthogonal(blank[blank.size() - 2].getStartPoint(), blank[blank.size() - 2].getEndPoint(), blank[blank.size() - 1].getStartPoint(), blank[blank.size() - 1].getEndPoint()))
    {
        clone = blank[blank.size() - 2];
        switch (clone.id)
        {
        case 1:
            clone.getEndPoint().y() > clone.getStartPoint().y() ? clone.getEndPoint().setY(clone.getEndPoint().y() - elem.arcR) : clone.getEndPoint().setY(clone.getEndPoint().y() + elem.arcR);
            elem.arcCenter.setY(clone.getEndPoint().y());
            break;
        case 2:
            clone.getEndPoint().x() > clone.getStartPoint().x() ? clone.getEndPoint().setX(clone.getEndPoint().x() - elem.arcR) : clone.getEndPoint().setX(clone.getEndPoint().x() + elem.arcR);
            elem.arcCenter.setX(clone.getEndPoint().x());
            break;
        case 3:
            if(isEqual(blank[blank.size() - 1].getEndPoint().y(), blank[blank.size() - 2].getStartPoint().y()))
            {
                elem.arcCenter.setX(clone.getEndPoint().x());
                clone.getEndPoint().y() > clone.getStartPoint().y() ? elem.arcCenter.setY(clone.getEndPoint().y() - elem.arcR * sqrt(2.0)) : elem.arcCenter.setY(clone.getEndPoint().y() + elem.arcR * sqrt(2.0));
            }
            else
            {
                clone.getEndPoint().x() > clone.getStartPoint().x() ? elem.arcCenter.setX(clone.getEndPoint().x() - elem.arcR * sqrt(2.0)) : elem.arcCenter.setX(clone.getEndPoint().x() + elem.arcR * sqrt(2.0));
                elem.arcCenter.setY(clone.getEndPoint().y());
            }
            clone.getEndPoint().x() > clone.getStartPoint().x() ? clone.getEndPoint().rx() -= elem.arcR / sqrt(2.0) : clone.getEndPoint().rx() += elem.arcR / sqrt(2.0);
            clone.getEndPoint().y() > clone.getStartPoint().y() ? clone.getEndPoint().ry() -= elem.arcR / sqrt(2.0) : clone.getEndPoint().ry() += elem.arcR / sqrt(2.0);
            break;
        default:
            break;
        }
        elem.getStartPoint() = clone.getEndPoint();
        blank[blank.size() - 2] = clone;
        blank[blank.size() - 2].getGraph()->clearData();
        blank[blank.size() - 2].getGraph()->setData({blank[blank.size() - 2].getStartPoint().y(),blank[blank.size() - 2].getEndPoint().y()}, {blank[blank.size() - 2].getStartPoint().x(),blank[blank.size() - 2].getEndPoint().x()});
        clone = blank[blank.size() - 1];
        switch (clone.id)
        {
        case 1:
            clone.getEndPoint().y() > clone.getStartPoint().y() ? clone.getStartPoint().setY(clone.getStartPoint().y() + elem.arcR) : clone.getStartPoint().setY(clone.getStartPoint().y() - elem.arcR);
            elem.arcCenter.setY(clone.getStartPoint().y());
            break;
        case 2:
            clone.getEndPoint().x() > clone.getStartPoint().x() ? clone.getStartPoint().setX(clone.getStartPoint().x() + elem.arcR) : clone.getStartPoint().setX(clone.getStartPoint().x() - elem.arcR);
            elem.arcCenter.setX(clone.getStartPoint().x());
            break;
        case 3:
            clone.getEndPoint().x() > clone.getStartPoint().x() ? clone.getStartPoint().rx() += elem.arcR / sqrt(2.0) : clone.getStartPoint().rx() -= elem.arcR / sqrt(2.0);
            clone.getEndPoint().y() > clone.getStartPoint().y() ? clone.getStartPoint().ry() += elem.arcR / sqrt(2.0) : clone.getStartPoint().ry() -= elem.arcR / sqrt(2.0);
            break;
        default:
            break;
        }
        elem.getEndPoint() = clone.getStartPoint();
        if(isEqual(elem.getStartPoint().x(), elem.arcCenter.x()))
        {
            if(elem.getStartPoint().y() > elem.arcCenter.y())
            {
                elem.getEndPoint().x() < elem.arcCenter.x() ? elem.codeElement = "G02" : elem.codeElement = "G03";
            }
            else
            {
                elem.getEndPoint().x() < elem.arcCenter.x() ? elem.codeElement = "G03" : elem.codeElement = "G02";
            }
        }
        else
        {
            if(elem.getStartPoint().x() > elem.arcCenter.x())
            {
                elem.getEndPoint().y() < elem.arcCenter.y() ? elem.codeElement = "G03" : elem.codeElement = "G02";
            }
            else
            {
                elem.getEndPoint().y() < elem.arcCenter.y() ? elem.codeElement = "G02" : elem.codeElement = "G03";
            }
        }
        blank[blank.size() - 1] = clone;
        elem.id = 4;
        blank.append(elem);
        addToEventList(blank.size() - 1);
        elem = blank[blank.size() - 2];
        blank[blank.size() - 2] = blank[blank.size() - 1];
        blank[blank.size() - 1] = elem;
        drawArc(blank.size() - 2, true);
    }
    else
    {
        logAction(messageType::JUNCTION_ERROR);
    }*/
}

//Функция, позволяющая мышкой выбирать элемент графика
void Project::definitionItemIndex(QMouseEvent *event)
{
     //считываем координаты точки на графике соответствующие месту клика мышкой
     double x = ui->widget->yAxis->pixelToCoord(event->pos().y());
     double y = ui->widget->xAxis->pixelToCoord(event->pos().x());
     double currentValue = 0.0; //вспомогательная переменная, хранящая текущее отклонение
     for(int i = 1; i < blank.size(); i++)
     {
         //условие проверки, позволяющее избежать ложных срабатываний
         if((blank[i]->getStartPoint().y() <= y && y <= blank[i]->getEndPoint().y()) || (blank[i]->getEndPoint().y() <= y && y <= blank[i]->getStartPoint().y()))
         {
             if(blank[i]->getCodeElement() == "G01") //проверка на принадлежность точки прямой
             {
                // если прямая задана точками (x1,y1) и (x2,y2), то уравнение прямой будет иметь вид:
                // (y1 - y2) * x + (x2 - x1) * y + (y2 * x1 - y1 * x2) = 0
                currentValue = (blank[i]->getStartPoint().y() - blank[i]->getEndPoint().y()) * x +
                     (blank[i]->getEndPoint().x() - blank[i]->getStartPoint().x()) * y +
                     (blank[i]->getStartPoint().x() * blank[i]->getEndPoint().y() - blank[i]->getStartPoint().y() * blank[i]->getEndPoint().x());
             }
             else //проверка на принадлежность точки дуге
             {
                //зная центр окружности (x1,y1) и радиус R, то уравнение окружности имеет вид:
                // (x - x1)^2 + (y - y1)^2 - R^2 = 0
                //currentValue = pow(x - blank[i].arcCenter.x(),2) + pow(y - blank[i].arcCenter.y(),2) - pow(blank[i].arcR, 2);
             }
             if (abs(currentValue) < 50.0) //если найденное абсолютное отклонение меньше указанного значения
             {
                 ui->EventList->setCurrentRow(i);
                 on_EventList_clicked(ui->EventList->model()->index(i,0));
                 break;
             }
         }
     }
}

void Project::showToolTip(QMouseEvent *event)
{
    for(QCPLayoutElement *element : ui->widget->plotLayout()->elements(true))
    {
        QCPAxisRect *axisRect = static_cast<QCPAxisRect *>(element);
        if(axisRect)
        {
            if(axisRect->rect().contains(event->pos()))
            {
                double x = ui->widget->yAxis->pixelToCoord(event->pos().y());
                double z = ui->widget->xAxis->pixelToCoord(event->pos().x());
                ui->widget->setToolTip(tr("%1,%2").arg(z).arg(x));
                break;
            }
        }
    }
}

//Функция, позволяющая вернуть элемент контура в исходное состояние
//next - текущий выбранный элемент, previous - элемент, который был выбран до текущего
void Project::repaintSelectedElement(QListWidgetItem* next, QListWidgetItem* previous)
{
    Q_UNUSED(next);
    //возвращаем предыдущий выбранный элемент в исходное состояние
    int currentIndex = ui->EventList->row(previous); //получаем индекс
    if(currentIndex > 0)
    {
        blank[currentIndex]->getGraph()->setSelected(false);
    }
}

void Project::on_EventList_clicked(const QModelIndex &index)
{
    setTransitionEnable(false);
    int currentIndex = index.row(); //получаем индекс
    if(currentIndex != 0) //возвращаем предыдущий выбранный элемент в исходное состояние
    {
        blank[currentIndex]->getGraph()->setSelected(true);
        ui->widget->replot();
    }
    blank[currentIndex]->setParameters(ui);

    ui->RemoveButton->setEnabled(true);
    ui->ChangeButton->setEnabled(true);
}

//Добавление нового элемента (инициализация параметров)
void Project::on_CreateButton_clicked()
{
    switch (ui->ElementParametrs->currentIndex()) //ID текущего добавляемого элемента (0 - начальная точка / 1 - прямая X / 2 - прямая Z / 3 - прямая / 4 - окружность)
    {
        case 0:
        {
            blank.append(new StartingPoint (QPointF(ui->SP_argX_value->value(),ui->SP_argZ_value->value())));
            setAddEnable(true); //делаем доступными для нажатия кнопки добавления различных элементов
            break;
        }
        case 1:
        {
            blank.append(new HorizontalLine (blank.last()->getEndPoint(), QPointF(blank.last()->getEndPoint().x(), ui->LZ_argZ_value->value())));
            break;
        }
        case 2:
        {
            blank.append(new VerticalLine (blank.last()->getEndPoint(), QPointF(ui->LX_argX_value->value(), blank.last()->getEndPoint().y())));
            break;
        }
        case 3:
        {
            blank.append(new Line(blank.last()->getEndPoint(), QPointF(ui->L_argX_value->value(), ui->L_argZ_value->value())));
            break;
        }
        case 4:
        {
            QString code = ui->DirectionButton->styleSheet().contains("left") ? "G03" : "G02";
            qDebug() << code;
            if(ui->C_argR_value->value() != 0)
            {
                Circle *element = new Circle(code, ui->C_argR_value->value(), blank.last()->getEndPoint(), QPointF(ui->C_argX_value->value(), ui->C_argZ_value->value()));
                setSelectCenterEnable(true);
                setAddEnable(false);
                blank.append(element);
            }
            else
            {
                blank.append(new Circle(code, QPointF(ui->C_argI_value->value(), ui->C_argJ_value->value()), blank.last()->getEndPoint(), QPointF(ui->C_argX_value->value(), ui->C_argZ_value->value())));
            }
            break;
        }
    }
    /*if(blank.size() > 1 && blank[blank.size() - 2].k != 0.0)
    {
        computeIntersectionPoint();
        drawElement(blank.size() - 2);
    }*/
    //механизм отрисовки фасок и скруглений
    for(int i = 0; i <= transitions.size() - 1; i++)
    {
        if(!transitions[i].isDraw)
        {
            transitions[i].R != 0.0 ? drawRounding(i) : drawChamfer(i);
            transitions.removeLast();
        }
    }

    if((ui->argFSX_value->value() != 0.0) || (ui->argFSZ_value->value() != 0.0) || (ui->argR_value->value() != 0.0)||(ui->argAlpha_value->currentIndex() != 0))
    {
        Transition item;
        item.FSX = ui->argFSX_value->value();
        item.FSZ = ui->argFSZ_value->value();
        item.R = ui->argR_value->value();
        item.alpha = ui->argAlpha_value->currentText().toDouble() * M_PI / 180.0;
        item.isDraw = false;
        transitions.append(item);
    }

    if(blank.size() > 1)
    {
        redraw(blank.size() - 1);
    }
    addToEventList(blank.size() - 1);

    ui->CreateButton->setDisabled(true);
}

//Добавление элемента в общий список и вывод его на окно приложения
void Project::addToEventList(int index)
{
    if(index > ui->EventList->count() - 1)
    {
        ui->EventList->addItem(blank[index]->createItem()); //добавление созданного элемента на боковую панель
    }
    else
    {
        delete ui->EventList->takeItem(index);
        ui->EventList->insertItem(index, blank[index]->createItem());
    }
    ui->EventList->scrollToBottom();
    logAction(messageType::ELEMENT_ADD, index);
}

//функция логирования
void Project::logAction(messageType currentType, int index)
{
    switch(currentType)
    {
        case messageType::INITIALIZATION_BLANK:
            ui->DialogBox->insertPlainText("Введите начальную точку");
            break;
        case messageType::ELEMENT_ADD:
            ui->DialogBox->insertPlainText("Добавлен элемент " + blank[index]->GCode());
            break;
        case messageType::ELEMENT_REMOVE:
            ui->DialogBox->insertPlainText("Элемент " + blank[index]->GCode() + " успешно удален");
            break;
        case messageType::ELEMENT_CHANGE:
            // do something
            break;
        case messageType::HAS_GAP:
            ui->DialogBox->insertPlainText("Контур не замкнут. Устраните разрыв");
            break;
        case messageType::NO_GAP:
            ui->DialogBox->insertPlainText("Контур замкнут");
            break;
        case messageType::PARSE_ERROR:
            ui->DialogBox->setTextColor(Qt::red);
            ui->DialogBox->insertPlainText("Неизвестная команда " + blank.last()->getCodeElement() + " в строке " + QString::number(blank.size()));
            ui->DialogBox->setTextColor(Qt::black);
            break;
        case messageType::JUNCTION_ERROR:
        {
            QString elementType = "";
            transitions.last().R != 0.0 ? elementType = " скругления " : elementType = " фаски ";
            ui->DialogBox->setTextColor(Qt::red);
            ui->DialogBox->insertPlainText("Ошибка создания" + elementType + ": Элементы не ортогональны или не сонаправлены");
            ui->DialogBox->setTextColor(Qt::black);
            break;
        }
        case messageType::SELECT_ARC_CENTER:
            ui->DialogBox->insertPlainText("Укажите правильный центр окружности");
            break;
        case messageType::NO_INTERSECTION:
            ui->DialogBox->setTextColor(Qt::red);
            ui->DialogBox->insertPlainText("Не удается вычилить точку пересечения. Элемент был удален");
            ui->DialogBox->setTextColor(Qt::black);
            break;
    }
    ui->DialogBox->insertPlainText("\n");
    ui->DialogBox->ensureCursorVisible();
}

//сохранение G-кода в файл
void Project::saveFile()
{
    QFile saveFile(QApplication::applicationDirPath() + "/models/" + ui->string_name->text() + ".nc"); //имя файла + место сохранения
    if (!saveFile.open(QIODevice::WriteOnly | QIODevice::Truncate)) //открытие файла на запись и его очистка
    {
        QMessageBox::critical(this, "Ошибка","Не удается открыть файл для записи");
    }
    else
    {
        for(int i = 0; i < blank.size(); i++)//запись текущего G-элемента в файл
        {
            saveFile.write(blank[i]->GCode().toUtf8() + "\n");
        }
        saveFile.close();
        blank.clear();
    }
}

bool Project::isDifferent()
{
    QFile cur_file(QApplication::applicationDirPath() + "/models/" + ui->string_name->text() + ".nc");
    int rows = 0;
    bool hasDifferences = false;
    if ((cur_file.open(QIODevice::ReadOnly | QIODevice::Text)))
    {
       while(!cur_file.atEnd())
       {
           if(cur_file.readLine() != blank[rows]->GCode().toUtf8() + "\n")
           {
                hasDifferences = true;
                break;
           }
           rows++;
       }
    }

    if(rows != blank.size())
    {
        hasDifferences = true;
    }

    return hasDifferences;
}

//Нажатие кнопки Завершить
void Project::on_EndButton_clicked()
{
    if (QFile(QApplication::applicationDirPath() + "/models/" + ui->string_name->text() + ".nc").exists()) //проверка, что перезаписываем существующий файл
    {
        if(isDifferent())
        {
            QMessageBox messageBox;
            messageBox.setWindowTitle("Перезапись файл");
            messageBox.setIcon(QMessageBox::Question);
            messageBox.setText("Файл \"" + ui->string_name->text() + ".nc\" уже существует. Вы уверены, что хотите перезаписать его?");
            messageBox.setStandardButtons(QMessageBox::Ok | QMessageBox::Cancel);
            messageBox.setButtonText(QMessageBox::Ok, tr("Да"));
            messageBox.setButtonText(QMessageBox::Cancel, tr("Нет"));
            messageBox.setDefaultButton(QMessageBox::Ok);
            switch (messageBox.exec()) //подтверждение или отклонение перезаписи файла
            {
                case QMessageBox::Ok: //подтверждение и последующая перезапись файла
                    saveFile();
                    break;
                case QMessageBox::Cancel: //отмена перезаписи
                    bool ok;
                    QString newBlankName = "";
                    while(newBlankName.isEmpty())
                    {
                        newBlankName = QInputDialog::getText(this, "Переименовать", "Введите новое имя заготовки:", QLineEdit::Normal, "", &ok); //ввод нового имени для файла
                        if(!ok) //отмена ввода -> полностью отменяем запись в файл;
                        {
                            return;
                        }
                        else if(!newBlankName.isEmpty()) //если введеное имя не пустое занова вызываем функцию записи в файл
                        {
                            ui->string_name->setText(newBlankName);
                            on_EndButton_clicked();
                        }
                    }
                    break;
            }
        }
    }
    else //если файла с указанным именем нет, то создаем его и записываем в него наш G-код
    {
        saveFile();
    }

    Widget *window = new Widget();//открытие стартового окна
    window->show();
    close();
}

//Функция парсинга открываемого файла
//project_name - имя открываемого файла
void Project::parseFile(QString project_name)
{
    QFile blankFile(QApplication::applicationDirPath() + "/models/" + project_name + ".nc");
    blankFile.open(QIODevice::ReadOnly);
    //BlankElement elem;
    QStringList commandArguments = QString(blankFile.readLine().trimmed()).split(" ");
    blank.append(new StartingPoint(QPointF(commandArguments[1].mid(1,commandArguments[1].size() - 1).toDouble(), commandArguments[2].mid(1,commandArguments[2].size() - 1).toDouble())));
    addToEventList(blank.size() - 1);
    while(!blankFile.atEnd())
    {
        commandArguments = QString(blankFile.readLine().trimmed()).split(" ");
        if(commandArguments[0] == "G01")
        {
            if(commandArguments.size() > 2)
            {
                blank.append(new Line(blank.last()->getEndPoint(),
                                      QPointF(commandArguments[1].mid(1,commandArguments[1].size() - 1).toDouble(), commandArguments[2].mid(1,commandArguments[2].size() - 1).toDouble())));
            }
            else
            {
                if(commandArguments[1].startsWith("Z"))
                {
                   blank.append(new HorizontalLine(blank.last()->getEndPoint(),
                                                    QPointF(blank.last()->getEndPoint().x(), commandArguments[1].mid(1,commandArguments[1].size() - 1).toDouble())));
                }
                if(commandArguments[1].startsWith("X"))
                {
                    blank.append(new VerticalLine(blank.last()->getEndPoint(),
                                                     QPointF(commandArguments[1].mid(1,commandArguments[1].size() - 1).toDouble(), blank.last()->getEndPoint().y())));
                }
            }
        }
        else if((commandArguments[0] == "G02") || (commandArguments[0] == "G03"))
        {
            QPointF end, center;
            end = QPointF(commandArguments[1].mid(1,commandArguments[1].size() - 1).toDouble(), commandArguments[2].mid(1,commandArguments[2].size() - 1).toDouble());
            if(commandArguments[3].startsWith("R"))
            {
                Circle *element = new Circle(commandArguments[0], commandArguments[3].mid(1,commandArguments[3].size() - 1).toDouble(), blank.last()->getEndPoint(), end);
                setSelectCenterEnable(true);
                logAction(messageType::SELECT_ARC_CENTER);
                blank.append(element);
                redraw(blank.size() - 1);
                QEventLoop loop;
                connect(ui->AddCircleCenter, SIGNAL(clicked()), &loop, SLOT(quit()));
                loop.exec();
                center = element->getArcCenter();
                delete ui->EventList->takeItem(blank.size() - 1);
                blank.removeLast();
            }
            else
            {
                center = QPointF(commandArguments[3].mid(1,commandArguments[3].size() - 1).toDouble(), commandArguments[4].mid(1,commandArguments[4].size() - 1).toDouble());
            }
            blank.append(new Circle(commandArguments[0], center, blank.last()->getEndPoint(), end));
        }
        else
        {
            StartingPoint *error = new StartingPoint();
            error->setCodeElement(commandArguments.join(" ").trimmed());
            blank.append(error);
            logAction(messageType::PARSE_ERROR);
            blank.removeLast();
            return;
        }
        redraw(blank.size() - 1);
        addToEventList(blank.size() - 1);
    }
}

void Project::on_RemoveButton_clicked()
{
    ui->EventList->clearSelection();
    int removeIndex = ui->EventList->currentRow();
    logAction(messageType::ELEMENT_REMOVE, removeIndex);
    delete blank[removeIndex]->getGraph();
    delete ui->EventList->takeItem(removeIndex);
    blank.removeAt(removeIndex);
    ui->widget->replot();

    if(removeIndex < blank.size())
    {
        QMessageBox messageBox;
        messageBox.setWindowTitle("Разрыв контура");
        messageBox.setIcon(QMessageBox::Question);
        messageBox.setText("Хотите автоматически устранить его?");
        messageBox.setStandardButtons(QMessageBox::Yes | QMessageBox::No);
        messageBox.setButtonText(QMessageBox::Yes, tr("Да"));
        messageBox.setButtonText(QMessageBox::No, tr("Нет"));
        messageBox.setDefaultButton(QMessageBox::Yes);

        ui->RemoveButton->setEnabled(false);
        ui->ChangeButton->setEnabled(false);

        switch (messageBox.exec())
        {
            case QMessageBox::Yes:
            {
                if(isEqual(blank[removeIndex - 1]->getEndPoint().x(), blank[removeIndex]->getStartPoint().x()))
                {
                    blank.insert(removeIndex, new HorizontalLine(blank[removeIndex - 1]->getEndPoint(), blank[removeIndex]->getStartPoint()));
                }
                else if(isEqual(blank[removeIndex - 1]->getEndPoint().y(), blank[removeIndex]->getStartPoint().y()))
                {
                    blank.insert(removeIndex, new VerticalLine(blank[removeIndex - 1]->getEndPoint(), blank[removeIndex]->getStartPoint()));
                }
                else
                {
                    blank.insert(removeIndex, new Line(blank[removeIndex - 1]->getEndPoint(), blank[removeIndex]->getStartPoint()));
                }
                ui->EventList->insertItem(removeIndex, blank[removeIndex]->createItem());
                redraw(removeIndex);

                break;
            }
            case QMessageBox::No:
            {
                while(blank[removeIndex - 1]->getEndPoint() != blank[removeIndex]->getStartPoint())
                {
                    logAction(messageType::HAS_GAP);
                    blank.append(blank[removeIndex - 1]);
                    QEventLoop loop;
                    connect(ui->CreateButton, SIGNAL(clicked()), &loop, SLOT(quit()));
                    loop.exec();
                    if(dynamic_cast<Circle*>(blank.last()))
                    {
                        if(!isEqual(static_cast<Circle*>(blank.last())->getR(), 0.0))
                        {
                            delete ui->EventList->takeItem(ui->EventList->count() - 1);
                            connect(ui->AddCircleCenter, SIGNAL(clicked()), &loop, SLOT(quit()));
                            loop.exec();
                            ui->widget->replot();
                        }
                    }
                    BlankElement * temp = blank.last();
                    for(int i = removeIndex; i < blank.size(); i++)
                    {
                        BlankElement * swapItem = blank[i];
                        blank[i] = temp;
                        temp = swapItem;
                    }
                    blank.removeLast();
                    ui->EventList->insertItem(removeIndex, blank[removeIndex]->createItem());
                    delete ui->EventList->takeItem(ui->EventList->count() - 1);
                    removeIndex++;
                }
                break;
            }
        }

        logAction(messageType::NO_GAP);
    }
}

void Project::on_ChangeButton_clicked()
{
    int currentIndex = ui->EventList->currentRow();
    blank[currentIndex]->changeParameters(ui);
    addToEventList(currentIndex);
    ui->EventList->clearSelection();
    ui->widget->replot();
    ui->ChangeButton->setDisabled(true);
    ui->RemoveButton->setDisabled(true);
}

//============================================================
//======== блокировка = взаимноисключающих = значений ========
//============================================================
void Project::on_L_argX_value_valueChanged(double arg1)
{
    if(arg1 != 0.0)
    {
        ui->L_argAlpha_value->setEnabled(false);
    }
    else if(ui->L_argZ_value->value() == 0.0)
    {
        ui->L_argAlpha_value->setEnabled(true);
    }
}

void Project::on_L_argZ_value_valueChanged(double arg1)
{
    if(arg1 != 0.0)
    {
        ui->L_argAlpha_value->setEnabled(false);
    }
    else if(ui->L_argX_value->value() == 0.0)
    {
        ui->L_argAlpha_value->setEnabled(true);
    }
}

void Project::on_L_argAlpha_value_valueChanged(double arg1)
{
    if(arg1 != 0.0)
    {
        ui->L_argX_value->setEnabled(false);
        ui->L_argZ_value->setEnabled(false);
    }
    else
    {
        ui->L_argX_value->setEnabled(true);
        ui->L_argZ_value->setEnabled(true);
    }
}

void Project::on_C_argR_value_valueChanged(double arg1)
{
    if(arg1 != 0.0)
    {
        ui->C_argI_value->setEnabled(false);
        ui->C_argJ_value->setEnabled(false);
    }
    else
    {
        ui->C_argI_value->setEnabled(true);
        ui->C_argJ_value->setEnabled(true);
    }
}

void Project::on_C_argI_value_valueChanged(double arg1)
{
    if(arg1 != 0.0)
    {
        ui->C_argR_value->setEnabled(false);
    }
    else if(ui->C_argJ_value->value() == 0.0)
    {
        ui->C_argR_value->setEnabled(true);
    }
}

void Project::on_C_argJ_value_valueChanged(double arg1)
{
    if(arg1 != 0.0)
    {
        ui->C_argR_value->setEnabled(false);
    }
    else if(ui->C_argI_value->value() == 0.0)
    {
        ui->C_argR_value->setEnabled(true);
    }
}

void Project::on_argR_value_valueChanged(double arg1)
{
    if(arg1 != 0.0)
    {
        ui->argAlpha_value->setEnabled(false);
        ui->argFSX_value->setEnabled(false);
        ui->argFSZ_value->setEnabled(false);
    }
    else
    {
        ui->argAlpha_value->setEnabled(true);
        ui->argFSX_value->setEnabled(true);
        ui->argFSZ_value->setEnabled(true);
    }
}

void Project::on_argFSX_value_valueChanged(double arg1)
{
    if(arg1 != 0.0)
    {
        ui->argR_value->setEnabled(false);
        ui->argFSZ_value->setEnabled(false);
    }
    else if(ui->argAlpha_value->currentIndex() == 0)
    {
        ui->argR_value->setEnabled(true);
        ui->argFSZ_value->setEnabled(true);
    }
}

void Project::on_argFSZ_value_valueChanged(double arg1)
{
    if(arg1 != 0.0)
    {
        ui->argR_value->setEnabled(false);
        ui->argFSX_value->setEnabled(false);
    }
    else if(ui->argAlpha_value->currentIndex() == 0)
    {
        ui->argR_value->setEnabled(true);
        ui->argFSX_value->setEnabled(true);
    }
}

void Project::on_argAlpha_value_currentIndexChanged(int index)
{
    if(index != 0)
    {
        ui->argR_value->setEnabled(false);
    }
    else if((ui->argFSX_value->value() == 0.0) && (ui->argFSZ_value->value() == 0.0))
    {
        ui->argR_value->setEnabled(true);
        ui->argFSX_value->setEnabled(true);
        ui->argFSZ_value->setEnabled(true);
    }
}
//============================================================
//============================================================
//============================================================
